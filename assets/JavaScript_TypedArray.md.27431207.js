import{_ as e,c as r,o as a,a as t}from"./app.31c7625e.js";const d="/answer-blog-web/assets/typed_arrays.9771316f.png",f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"缓冲与视图","slug":"缓冲与视图","link":"#缓冲与视图","children":[]}],"relativePath":"JavaScript/TypedArray.md","lastUpdated":1670493823000}'),c={name:"JavaScript/TypedArray.md"},o=t('<h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-hidden="true">#</a></h2><p><code>JavaScript</code> 类型化数组(<code>typed array</code>) 是一种类似数组的对象， 并提供了一种用于在内存缓冲区中访问原始二进制数据的机制。 在某些功能(音视频编辑、访问<code>WebSockets</code>原始数据)，使用<code>js</code>代码可以快速方便的通过类型化数组对原始二进制数据进行操作。<br> 但是，<code>typed array</code> 并不是真正意义上的“数组”。通过<code>Array.isArray()</code>方法可以证明。而且某些数组的方法并不被支持（如<code>pop</code>,<code>push</code>等)</p><h2 id="缓冲与视图" tabindex="-1">缓冲与视图 <a class="header-anchor" href="#缓冲与视图" aria-hidden="true">#</a></h2><p>为了达到最大的灵活性与效率，类型化数组被拆分为<code>缓冲</code>和<code>视图</code>两部分。<br> 缓冲描述的是一个数据分块，没有格式，不提供访问内容的机制。<br> 视图提供上下文(数据类型、起始偏移量、元素)，将数据转换为有实际类型的数组。 <img src="'+d+'" alt="选择功能"><br> 理解： 长度为1的<code>ArrayBuffer</code>有16 Bytes(字节)，而一个字节有8bit。<br> 所以<code>Uint8Array</code>表示 16Bytes * 8bit / 8 = 128bit / 8 = 16 区间分为16块<br><code>Uint16Array</code>表示 16Bytes * 8bit / 16 = 128bit / 16 = 8 区间分为8块</p>',4),s=[o];function i(n,p,_,l,h,y){return a(),r("div",null,s)}const u=e(c,[["render",i]]);export{f as __pageData,u as default};
