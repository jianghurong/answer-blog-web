## 1. 高阶函数  

高阶函数是指可以满足下列条件之一的函数  

* 函数可以作为参数被传递
* 函数可以作为返回值输出  

``JavaScript`` 中的函数满足高阶函数的条件  

### 1.1 函数作为参数传递

把函数当做参数传递，这代表我们可以**抽离出一部分容易变化**的业务逻辑。把这部分逻辑放在函数参数中，这样可以分离业务代码中变化与不变的部分，其中一个重要应用就是常见的回调函数。

#### 1.1.1 回调函数  

在 ``ajax`` 异步请求中，回调函数的使用非常频繁。
当我们想在 ``ajax`` 请求返回之后做些事情，但又并不知道请求返回的确切时间时。
最常见的方案就是把 ``callback`` 函数当做参数传入发起 ``ajax`` 请求的方法中，
待请求完成之后执行 ``callback`` 函数。  
例:
```js
let getUserInfo = function (userId, callback) {
    $.ajax('http://www.baidu.com/getUserInfo?' + userId, function (data) {
        if (typeof callback === 'function') callback(data)
    })
}

getUserInfo(211, function (data) {
    alert(data)
})
```  
回调函数的应用不只是在异步请求中，当一个函数不适合执行一些事件时。我们也可以把这些事件封装成一个函数B。并把它作为参数传给另一个函数A，由函数A来执行。  
比如，我们想在页面中创建 100 个 ``div`` 节点，然后将这些节点设为隐藏。  
例:
```js
function createNode (count) {
    if (typeof count !== 'number') return
    for (let i = 0; i < count; i++) {
        let dom = document.createElement('div')
        dom.style.display = 'none'
        // or dom.setAttribute('hidden', true)
        document.body.appendChild(dom)
    }
}

createNode(100)
```
把 ``dom.style.diaplay = 'none'`` 的逻辑硬编码在 ``createNode`` 显然是不合理的，会使其成为一个难用复用的函数，并不是每个人创建了节点之后就希望它们立刻被隐藏。  
于是可以把 ``dom.style.display = 'none'`` 抽出来，作为回调函数传入 ``createNode`` 函数中。  
例:  
```js
function hiddenNode (dom) {
    dom.style.display = 'none'
}

function createNode(count, callback) {
     if (typeof count !== 'number') return
    for (let i = 0; i < count; i++) {
        let dom = document.createElement('div')
        if (typeof callback === 'function') callback(dom)
        document.body.appendChild(dom)
    }
}

createNode(100, hiddenNode)
```
可以看到，隐藏节点的请求实际上是我们主动发起的，但是我们并不知道节点什么时候会创建好。
于是把隐藏节点的请求放在回调函数中，“委托”给 ``createNode`` 方法。节点创建好之后，
``createNode`` 会执行之前我们传入的回调函数。  

#### 1.1.2 Array.prototype.sort  

``sort`` 函数接受一个函数当做参数，这个函数里面封装了数组元素的排序规则。  
从 ``sort`` 函数的使用可以看到。我们的目的是对数组进行排序，这是不变的部分；
而使用什么规则去排序，则是可变的部分。把可变的部分封装在函数参数里，动态传入
``sort`` 函数中。使其成为一个非常灵活的方法。  
例:
```js
// 从小到大排列
[11, 5, 3, 2, 6].sort(function (a, b) {
    return a - b
})
```
自定义实现 ``sort``:
```js

Array.prototype._sort = _sort // 注册为原型方法

function _sort (fn) {
    for (let i = 0; i < this.length - 1; i++) {
        for (let j = 0; j < this.length - 1 - i;j++) {
            if (fn(this[j], this[j + 1]) > 0) {
                let temp = this[j]
                this[j] = this[j + 1]
                this[j + 1] = temp
            }
        }
    }
    return this
}

[11, 5, 3, 2, 6]._sort(function (a, b) {
    return a - b
})
```

### 1.2 函数作为返回值输出
